Explain how MVC naturally ends up with an event driven model.
Explain the complexity of debugging (e.g. backtraces all coming from the event
loop)

Behavior is no longer characterized by code alone. Emergent behavior arises from
the potentially asynchronous interaction among objects, communicating through
events. The communication network being mutable. This results in extremely 
complex, hard to understand, hard to debug designs.

Explain The event loop


ok. Imagine you have a bunch of things firing events, and you want to perform actions in response to these events. They can be a UI, or a socket, or maybe some hardware.
A design to handle this is to use an event loop. What it does is loop around (with a while True, really), checking the content of a queue. When the queue has some events in it (e.g. some stuff is available from the socket, or a mouse click has been made), it "dispatches the event" to the appropriate handler, which is a fancy way of saying "it calls a routine assigned to that event". You push that button, the push button event is added to the queue, and that routine is called. When the routine is done, you go back to the event loop, and process the next event.
This is all fine and dandy, but what happens if the event handler, the routine you wrote, takes some time to complete? If you are running on a single thread, that thread is the one that was executing the event loop, got dispatched, and now is stuck waiting for the handler to complete. Stuck there, all other events that are waiting in the queue cannot be handled, and your application is stuck until the handler is done, the thread goes back to the event loop, and the next event is processed. This is not optimal. How to solve this?
One solution is to spawn another thread, and let this other thread do the heavy, long running work, while the main thread goes back to the event loop and keeps processing events. But multithread programming is hard, and event driven multithread programming even more so.
So ideally, you would prefer to have a single thread, but when it encounters something that is long running, you use a trick to suspend the execution point, and resume it later, when the long running task is completed, or maybe you want to do it in steps, each one short, but taken together they run for a long time. the yield keyword, and therefore generators, happen to provide this exact service: suspend something and resume it later from where you left it.
When you reach the yield, the main thread can now go back to the event loop, and keep processing events. Somehow, where the execution was suspended to wait for a long running thing there will be some magic so that when the long running thing is done, the thread will know about it and go back to where it was suspended. This can be achieved either by a secondary thread, or by the main thread itself: when it runs out of events to process, it works on the long running task, maybe to be suspended again a little later.
What you see is what is known as collaborative (or cooperative) multitasking. The event loop is basically a "kernel", and yield points are equivalent to "system calls" into the "kernel". At this yield points, the control is returned to the kernel, which is now free to run something else, interleaving all the handling and keeping the event processing alive, instead of being stuck at one particular handler. Note that this mechanism requires collaboration: the individual handlers must yield to inform the "kernel" "I'm not done here yet, but give someone else a chance to keep going". This compares with preemptive multitasking where the kernel is the one saying: "that's it, you had enough fun, let's someone else go now", which is what modern real kernels do.
So asyncio is a form of event loop and collaborative multitasking to allow event driven programming without either having an unresponsive application or having to deal with multiple threads, callbacks and all the horror that arises from it in an event driven environment.
